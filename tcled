#! /usr/bin/env tclsh

set ABOUT {
tcled: A Linux console based editor in pure Tcl

Copyright (c) 2006 Steve Redler IV
Copyright (c) 2006 Jeffrey Hobbs
Copyright (c) 2015 Adly Abdulah
Copyright (c) 2015, Stefan Finzel
}

################################
# Preferences:
################################
# Shell to use for exec (F2).
# Set to empty string to exec directly without a shell:
set execShell $env(SHELL)
# How many spaces each tab character takes:
set tabstop 4
# Substitute spaces to tabs on newline and pasting:
set usetabs true
# Search is case sensitive:
set searchcase false
# Mouse wheel speed (lines to scroll):
set mousewheelSpeed 4
# Draw tab guide (can be toggled via alt-;):
set tabGuide 0
if {[fconfigure stdout -encoding] == "utf-8"} {
	# Tab guide character for utf8 capable terminals
	# set tabGuideChar \u2502
	set tabGuideChar \u2591
} else {
	# Tab guide character for plain ASCII terminals
	set tabGuideChar |
}

################################
# Syntax hilighting:
################################
array set bg {
	black 40 red 41 green 42 yellow 43
	blue 44 magenta 45 cyan 46 white 47
}
array set fg {
	black 30 red 31 green 32 yellow 33
	blue 34 magenta 35 cyan 36 white 37
}
array set style {
	none 0 bright 1 dim 2
	underline 4 blink 5 reverse 7
}

# set tabGuideColor "$fg(blue);$style(dim)"
set tabGuideColor "$style(dim)"

# RE for strings and numbers:
set STRINGS {{(\"(?:\\"|[^"])*")|('(?:\\'|[^'])*')}}
set STRING_STYLE "$style(bright);$fg(yellow)"
set NUMBERS {{\y(0x[0-9a-fA-F]+|[0-9][0-9\.]*)\y}}
set NUMBER_STYLE "$style(bright);$fg(red)"

set COMMENT_FORMAT {$fg(green)}

set syntaxRules {
	# The syntax rules is in the form:
	# {filepattern} {{regexp} {formatting}...}
	# Comments in here are ignored.

	{^(po|pot)$} {
		{#:.+$} {$style(underline)}
		{#,\s*fuzzy.*$} {$fg(yellow);$bg(red);$style(bright)}
		{msgid|msgstr} {$bg(cyan);$fg(black)}
		$STRINGS {}
		$NUMBERS {}
	}

	# C and js comments
	{^(c|cc|cpp|h|hh|js|fe|fec|feh|osm|go|php|java)$|\ynode(js)?\y|\yferite\y} {
		# Comments:
		{(?:^|[^\\])//.*$} $COMMENT_FORMAT
		
		# Fake /* .. */ style comments:
		{/\*.*?\*/} $COMMENT_FORMAT
		# /* ...
		{/\*.*(?!\*/).*$} $COMMENT_FORMAT
		# * ...
		{^\s*\*\s.*$} $COMMENT_FORMAT
		# ... */
		{^[^(?!/\*)]*\*/} $COMMENT_FORMAT
		
		{/\*.*} $COMMENT_FORMAT
	}

	# C
	{^(c|cc|cpp|h|hh)$} {
		# Preprocess:
		{(?:^|;)\s*#.*$} {$fg(yellow)}
		
		# Traditional constants:
		{\y([A-Z_][A-Z0-9_]+)\y} {$style(bright)}
		
		# Types:
		{\y(volatile|void|const|struct|signed|unsigned|register|union)\y}
			{$style(bright);$fg(cyan)}
		{\y(bool|char|short|int|long|double|float|enum|bit|static)\y}
			{$style(bright);$fg(cyan)}
		
		# Keywords:
		{\y(auto|break|case|case:|continue|default|do|else|extern)\y}
			{$fg(cyan)}
		{\y(for|goto|if|return|switch|typedef|while)\y}
			{$fg(cyan)}
			
		# PIC specific, I/O:
		{\y(?:PORT|TRIS)[A-Z]\y} {$style(bright);$fg(red)}
		{\yTRIS[A-Z][0-8]\y} {$style(bright);$fg(red)}
		{\yR[A-Z][0-8]\y} {$style(bright);$fg(red)}
	}
	
	# go
	{go$} {
		# Keywords:
		{\y(break|default|func|interface|select|case|defer|go|map|struct)\y}
			{$fg(cyan)}
		{\y(chan|else|goto|package|switch|const|fallthrough|if|range)\y}
			{$fg(cyan)}
		{\y(type|continue|for|import|return|var)\y}
			{$fg(cyan)}
		
		# Built-in types:
		{\y(u?int(?:8|16|32|64)?|float(?:32|64)|complex(?:64|128))\y}
			{$style(bright);$fg(magenta)}
		{\y(byte|rune|uintptr|string|bool)\y}
			{$style(bright);$fg(magenta)}
	
		# Raw string literals (backticks):
		{`.*?`} {$STRING_STYLE}	
		
		# Treat true, false etc. like numbers:
		{\y(iota|true|false|nil)\y} {$NUMBER_STYLE}
	}
	
	# js
	{js$|\ynode\y} {
		# Keywords:
		{\y(break|case|catch|continue|default|delete|do|else|finally|for)\y}
			{$style(bright);$fg(cyan)}
		{\y(function|if|in|instanceof|new|return|switch|this|throw|try)\y}
			{$style(bright);$fg(cyan)}
		{\y(typeof|var|void|while|with)\y}
			{$style(bright);$fg(cyan)}
		
		# Reserved words:
		{\y(abstract|boolean|byte|char|class|const|debugger|double|enum)\y}
			{$fg(red)}
		{\y(export|extends|final|float|goto|implements|import|int|long)\y}
			{$fg(red)}
		{\y(interface|native|package|private|protected|public|short|static)\y}
			{$fg(red)}
		{\y(super|synchronized|throws|transient|volatile)\y}
			{$fg(red)}
			
		# Treat null and undefined like numbers:
		{\y(null|undefined)\y} {$NUMBER_STYLE}
	}
	
	{js$|\ynode\y|go$|fe|fec|feh|ferite|osm} {
		# Syntax elements:
		{[{}\[\]();,]} {$style(dim)}
		{[<>^~\-+*/!&|:=]} {$style(bright)}
	}
	
	{fe|fec|feh|ferite|osm} {
		# Treat null, true and false like numbers:
		{\y(null|true|false)\y} {$NUMBER_STYLE}
		
		# Keywords:
		{\y(closure|eval|return|super|new|for|do|monitor|handle|switch|function)\y}
			{$style(bright);$fg(cyan)}
		{\y(if|else|while|rename|recipient|deliver|using|arguments|global|default|isa|instanceof)\y}
			{$style(bright);$fg(cyan)}
			
		{\yWorkflow\.?\y}
			{$style(bright);$fg(yellow);$bg(blue)}
			
		# Types:
		{\y(string|array|number|object|void|boolean)\y}
			{$style(dim);$fg(cyan)}
		{\y(namespace|protocol|class|directive)\y}
			{$style(dim);$fg(cyan)}
			
		# Modifiers:
		{\y(modifies|extends|invoke|method_missing|case|(default)\s*:|implements)\y}
			{$style(bright);$fg(blue)}
		{\y(abstract|final|public|private|protected|static|constructor)\y}
			{$style(bright);$fg(blue)}
		
		# uses:	
		{^\s*uses.*$} {$style(bright);$fg(green);$bg(blue)}
		
		# Strings:
		{\"(?:\\"|[^"])*"} $STRING_STYLE
		{'(?:\\'|[^'])*'} {$STRING_STYLE;$style(dim)}
	}
	
	# m516 assembly
	{^as$} {
		# Comments:
		{(?:^|[^\\])//.*$} {$fg(green)}
		
		# Keywords:
		{\y(macro|include|define)\y} {$fg(cyan)}
		
		# Macro variables
		{(?i)\$[\w\:\$]*} {$style(bright);$fg(cyan)}
		
		# Basic macros
		{routine|saveret|return|goto|call|ifTRUE|ifFALSE|ifCARRY|ifBORROW}
			{$style(bright);$fg(blue)}
		{memset|getArray|setArray}
			{$style(bright);$fg(blue)}
		
		# Labels
		{:\w+} {$style(bright);$fg(yellow)}
	}
	
	# Makefile:
	{(?i)^makefile$} {
		# Targets:
		{^\s*[^=:]+:} {$style(bright);$fg(white);$bg(blue)}
		
		# Variables:
		{\$\(\S+\)} {$style(bright);$fg(cyan)}
		{^\s*(\S+)\s*=} {$fg(cyan)}
	}

	# Special empty filepattern matches all files:
	{} {
		# Strings & numbers:
		$STRINGS {$STRING_STYLE}
		$NUMBERS {$NUMBER_STYLE}

		# File magics:
		{^#!.*$} {$style(bright);$fg(green);$bg(blue)}
		{^\s*package\s+.*$} {$style(bright);$fg(green);$bg(blue)}

		# Script comments/C preprocessing
		{(?:^|;)\s*#.*$} $COMMENT_FORMAT

		# Email address:
		{(?i)(?:[a-z0-9-]+\.\:)*[a-z0-9-]+\@(?:[a-z0-9-]+\.)*[a-z0-9-]+}
			{$style(bright)}
			
		# End of line continuation:
		{\\\s*$} {$style(dim)}
	}

	# Spec file:
	{spec|dist} {
		{^\w+:} {$fg(yellow)}
		{^%(?:desc|pre|build|install|clean|files|post|changelog)\w*}
		{$bg(cyan);$fg(black)}
	}
	
	{\y(tcl|tm|tclsh|wish)\y} {
		# dictobject syntax
		{(?i)(?:\%[a-z_\:][\w:]*)(\.[\w\:\.]*)} {$fg(yellow)}
		
		# Tcl variable names after a command:
		{(?:set|append|incr|variable)\s+([a-zA-Z_\.]\w*)} {$fg(cyan)}
		{(?:global) ([a-zA-Z_\.][\w ]*)} {$fg(cyan)}

		# Functions, procs and subroutines:
		{(?:proc|sub|function|rename)\s+([a-zA-Z_\.\|]\w*)} {$style(bright)}
		{([a-zA-Z_\.]\w*)(?:\s*\()} {$style(bright)}
		
		# Syntax elements:
		{[{}\[\]]} {$style(dim)}
	}

	# Scripts
	{\y(sh|perl|cgi|pm|pl|py|spec|tcl|tm|tclsh|wish)\y} {
		# Script style variables:
		{(?i)\$[a-z_\.\:][\w\:]*} {$style(bright);$fg(cyan)}
		{(?i)[\@\%][a-z_\.\:][\w\:]*} {$style(bright);$fg(yellow)}
	}
	{\y(sh|perl|cgi|pm|pl|py|spec|bash)\y} {
		# Backtick exec:
		{`.*?`} {$bg(yellow);$fg(black)}
	}
	
	# Perl:
	{perl|ps|pm|awk} {
		{'.*?'} {$fg(magenta)}
		{(?:s|tr)(/(?:.*?[^\\])??)/(?:.*?[^\\])??/} {$bg(green);$fg(black)}
		{(?:s|tr)/(?:.*?[^\\])??(/(?:.*?[^\\])??/)} {$bg(white);$fg(black)}
	}
	# Regexp literal:
	{\y(perl|ps|pm|awk|js|node)\y} {
		{/(?:.*?[^\\])??/} {$bg(yellow);$fg(black)}
	}

	# Patch file:
	{patch|diff} {
		{^(?:\-\-\-|\+\+\+) .*$} {$bg(blue);$fg(white)}
		{^\@\@.*$} {$bg(yellow);$fg(black)}
		{^(?:\+|>).*$} {$bg(green);$fg(black)}
		{^(?:\-|<).*$} {$bg(red);$fg(black)}
		{^(diff.*)} {$bg(blue);$fg(white);$style(bright)}
	}

	# HTML:
	{htm|xml|svg|php} {
		{<!DOCTYPE.*?>} {$bg(blue);$fg(yellow)}
		{<!-.*?->} $COMMENT_FORMAT
		{<\w+|>|</\w+>} {$style(bright);$fg(cyan)}
	}

	{^asn$} {
	  {^\s*--.*$} $COMMENT_FORMAT
	  {^\s*(\w+)\s.*::=} {$fg(yellow)}
	}
}

set blockCommentRules {
	{^(c|cc|cpp|h|hh|js|fe|fec|feh|osm|go|php|java)$|\ynode(js)?\y|\yferite\y} "//"
	{^(asn|sql)$} "--"
	{} "#"
}

################################
# Globals
################################
set filename ""
set fileext ""
set searchpattern ""
set searchhistory ""
set debughistory ""
set exechistory ""
set gotohistory ""
set statusmessage ""
set modified 0
set viewRow 1
set viewCol 1
set bufRow 0
set bufCol 0
set undoBuffer ""
set redoBuffer ""
set writable 1
set autoCompleteMatches ""
set tabCompleteWord ""
set comeFrom ""
set keybuffer ""
set bufSelection {}
set mtime 0
set insertToSelection 0
set mouseMoved 0
set clickCount 0

###############################
# Backport lassign if < 8.5
###############################
if {[info commands lassign] == ""} {
	proc lassign {theList args} {
		foreach var $args val $theList {
			upvar 1 $var Var
			set Var $val
		}
	}
}


###############################
# Start Tk for clipboard
# support if possible
###############################
if {$tcl_platform(os) == "Darwin"} {
	# Don't use Tk on Mac, use pbcopy, pbpaste instead
	proc clipboard {cmd {ignore ""} {arg ""}} {
		switch $cmd {
			append {
				if {![catch {open "| pbcopy" w} f]} {
					puts $f $arg
					close $f
				}
			}
			get {
				return [exec pbpaste]
			}
		}
	}
} elseif {[catch {
	package require Tk
	wm overrideredirect . 1
	wm withdraw .
}]} {
	# Work-around clipboard if we can't load Tk.
	# We simply save data to ~/.clipboard
	proc clipboard {cmd {ignore ""} {arg ""}} {
		switch $cmd {
			clear {
				file delete ~/.clipboard
			}
			append {
				if {![catch {open ~/.clipboard a} f]} {
					puts -nonewline $f $arg
					close $f
				}
			}
			get {
				if {![catch {open ~/.clipboard r} f]} {
					set txt [read $f]
					close $f
					return $txt
				}
			}
		}
	}
	
	proc update {args} {}
}

################################
# Utilities
################################
proc drainStdin {} {
	# attempt to get all escape characters
	# on slow connections/terminals:
	if {$::tcl_platform(os) != "Darwin"} {
		after 10
	}
	append ::keybuffer [read stdin]
}

proc shift {ls} {
	upvar 1 $ls LIST
	set ret [lindex $LIST 0]
	set LIST [lrange $LIST 1 end]
	return $ret
}

proc ESC {args} {return "\033[join $args {}]"}

proc ESC_ {args} {ESC "\[" [join $args {}]}

proc REV {args} {ESC_ 7m [join $args {}]}

proc RESET {} {ESC_ 0m}

proc GOTO  {row col} {ESC_ $row ";" $col H}

proc SAVE {} {ESC_ s}

proc UNSAVE {} {ESC_ u}

proc LEFT {col} {ESC_ $col D}

proc RIGHT {col} {ESC_ $col C}

proc WINDOW_TITLE {str} {ESC "\]0;" $str "\007"}

proc regexpSafe {str} {
	string map {
		$ {\$} . {\.} * {\*} ^ {\^} ? {\?}
		( {\(} ) {\)} \{ {\\\{} \} {\\\}}
	} $str
}

proc readbuf {} {
	global keybuffer

	set ret [string index $keybuffer 0]
	set keybuffer [string range $keybuffer 1 end]
	if {$keybuffer == ""} {
		append keybuffer [read stdin]
	}
	return $ret
}


proc stringInsert {txt idx str} {
	return [string range $txt 0 [expr $idx-1]]$str[string range $txt [expr $idx] end]
}

proc endLine {} {
	global BUFFER bufRow bufCol
	set x [string length [lindex $BUFFER $bufRow]]
	if {$bufCol > $x} {
		set bufCol $x
	}
}

proc getSpaces {line} {
	global tabstop usetabs
	set ret [lindex [regexp -inline {^[[:space:]]+} $line] 0]
	if {$usetabs} {
		string map [list [string repeat " " $tabstop] "\t"] $ret
	} else {
		set ret
	}
}

proc inputStat {txt ret {len ""}} {
	global IDX
	set stat [string range "$txt $ret" 0 [expr {$IDX(ROWCOL)-1}]]
	if {$len == ""} {
		set len [expr [string length $stat]+1]
	} else {
		set len [expr {$len + [string length "$txt  "]}]
	}
	status $stat
	goto end $len
	flush stdout
}

proc historyAppend {thelist item} {
	upvar 1 $thelist hist

	if {[set hidx [lsearch -exact $hist $item]] != -1} {
		set hist [lreplace $hist $hidx $hidx]
	}
	lappend hist $item
}

proc drawMenu {selections {selected ""}} {
	global viewRow viewCol IDX
	
	set W $IDX(COLMAX)
	set H [expr {$IDX(ROWMAX)-1}]
	
	set w 60
	set h [expr {[llength $selections]+2}]
	
	if {$w > $W} {set w $W}
	if {$h > $H} {set h $H}
	
	set x $viewCol
	if {($x+$w) > $W} {
		set x [expr {$W-$w}]
	}
	set y $viewRow
	if {($y+$h) > $H} {
		set y [expr {$H-$h}]
	}
	goto $y $x
	puts -nonewline [REV [string repeat { } $w] [RESET]]
	incr y
	set j 0
	foreach i [lrange $selections 0 [expr {$h-2}]] {
		goto $y $x
		if {[string length $i] > ($w-2)} {
			set str [string range $i 0 [expr $w-5]]
			append str ..
		} else {
			set str $i
		}
		set l [string length $str]
		if {$l < ($w-2)} {
			set r [expr {$w-2-$l}]
			append str [string repeat { } $r]
		}
		if {$selected != $j} {
			puts -nonewline [REV " $str " [RESET]]
		} else {
			puts -nonewline [REV " " [RESET] $str [REV " "] [RESET]]
		}
		incr y
		incr j
	}
	goto $y $x
	puts -nonewline [REV [string repeat { } $w] [RESET]]
	flush stdout
}

proc selectMenu {selections {selected -1}} {
	global IDX keybuffer
	
	hideCursor
	drawMenu $selections $selected
	
	while {[set ch [readbuf]] != "\n" && $ch != "\r"} {
		if {$ch == ""} {
			after 40
			continue
		}
		if {$ch == [ESC]} {
			drainStdin

			# escape:
			if {$keybuffer == ""} {
				set selected -1
				break
			}
			
			# Handle up-down keys
			if {$keybuffer == "\[A"} {
				if {$selected > 0} {
					incr selected -1
				}
			} elseif {$keybuffer == "\[B"} {
				if {$selected < ([llength $selections]-1)} {
					incr selected
				}
			}
			drawMenu $selections $selected
		}
	}
	
	showCursor
	handleRedraw forced
	
	return $selected
}

proc waitForESC {} {
	status "Press ESC to exit this screen"
	flush stdout

	# Wait for ESC key:
	fconfigure stdin -blocking 1
	while 1 {if {[read stdin 1] == [ESC]} break}
	fconfigure stdin -blocking 0
	read stdin
}

proc getConfirmation {txt} {
	status "$txt Y/n"
	flush stdout
	fconfigure stdin -blocking 1
	while 1 {
		set line [read stdin 1]
		
		if {$line == "y" || $line == "Y" || $line == "\n"} {
			flush stdout
			fconfigure stdin -blocking 0
			return 1
		} elseif {$line == "n" || $line == "N" || $line == [ESC]} {
			flush stdout
			fconfigure stdin -blocking 0
			return 0
		}
	}
}

proc keyInput {txt script} {
	set opts {}
	foreach {o -} $script {
		lappend opts $o
	}
	status "$txt [join $opts /]"
	
	flush stdout
	fconfigure stdin -blocking 1
	while 1 {
		set line [read stdin 1]
		foreach o $opts {
			if {[string tolower $line] == [string tolower $o]} {
				uplevel 1 [list switch [string tolower $o] $script]
				flush stdout
				fconfigure stdin -blocking 0
				return
			}
		}
		if {$line == [ESC]} {
			uplevel 1 [list switch ESC $script]
			flush stdout
			fconfigure stdin -blocking 0
			return
		}
	}
}

proc getInput {{txt ""} {historybuffer ""}} {
	global viewRow viewCol keybuffer

	if {$historybuffer != ""} {
		upvar 1 $historybuffer hist
		set hidx -1
	}

	status ""
	goto end 1
	puts -nonewline [REV "$txt "]
	flush stdout
	set ret ""
	set inputCursor 0
	while {[set ch [readbuf]] != "\n" && $ch != "\r"} {
		if {$ch == ""} {
			after 40
			continue
		}
		if {$ch == [ESC]} {
			drainStdin

			# escape:
			if {$keybuffer == ""} {
				status ""
				return
			}
			
			switch -exact -- $keybuffer {	
				"\[C" { ;# Cursor Right
					if {$inputCursor < [string length $ret]} {
						incr inputCursor
					}
				} 
				"\[D" { ;# Cursor Left
					if {$inputCursor > 0} {
						incr inputCursor -1
					}
				}
				"OH" -
				"\[H" -
				"\[7~" -
				"\[1~" { ;# Home
					set inputCursor 0
				}
				"OF" -
				"\[F" -
				"\[K" -
				"\[8~" -
				"\[4~" { ;# End
					set inputCursor [string length $ret]
				}
				"\[A" -
				"\[B" {
					if {$historybuffer != ""} {
						# handle history if given:
						if {$keybuffer == "\[A"} {
							if {$hidx < ([llength $hist]-1)} {
								incr hidx
							}
						} elseif {$keybuffer == "\[B"} {
							if {$hidx >= 0} {
								incr hidx -1
							}
						}
						
						if {$hidx >= 0} {
							set ret [lindex $hist end-$hidx]
						} else {
							set ret ""
						}
						set inputCursor [string length $ret]
					}
				}
			}
			inputStat $txt $ret $inputCursor

			# need to ignore escapes sequences:
			# while {[set ch [readbuf]] != "~" && $keybuffer != ""} {}
			set firstEsc [string last [ESC] $keybuffer]
			if {$firstEsc == -1} {
				set keybuffer ""
			} else {
				set keybuffer [string range $keybuffer $firstEsc end]
			}
			continue
		} elseif {$ch == "\u007f" || $ch == "\u0008"} {
			# handle backspace:
			set ret [
				string range $ret 0 [expr $inputCursor-2]
			][
				string range $ret $inputCursor end
			]
			if {$inputCursor > 0} {
				incr inputCursor -1
			}
		} elseif {[string is print $ch]} {
			set ret [stringInsert $ret $inputCursor $ch]
			incr inputCursor
		}
		inputStat $txt $ret $inputCursor
	}
	return $ret
}

proc colFromViewCol {row vCol} {
	set col $vCol
	set c [getCol $row $col]
	
	if {$c == $col} {
		return $col
	}
	
	# Try to find the col value that would match the original vCol:
	while {$c > ($vCol+1) && $col > 0} {
		incr col -1
		set c [getCol $row $col]
	}
	return $col
}

proc getCol {row bCol {pos "start"}} {
	global BUFFER tabstop

	set col 0
	set i 0
	foreach c [split [lindex $BUFFER $row] ""] {
		if {$i >= $bCol} break
		if {$c == "\t"} {
			# align to tabs:
			incr col [expr {$tabstop-$col%$tabstop}]
		} else {
			incr col
		}
		incr i
	}
	if {
		$pos != "start" &&
		[string range [lindex $BUFFER $row] $i $i] == "\t"
	} {
		incr col $tabstop
	}
	incr col
}

proc drawStatus {txt {offset 0}} {
	global IDX

	if {$offset == 0} {
		set len $IDX(ROWCOL)
	} else {
		set len $IDX(COLMAX)
	}
	set str [format "%-${len}.${len}s" $txt]
	puts -nonewline [REV [GOTO [expr {$IDX(ROWMAX)-$offset}] 0] $str [RESET]]
	goto cursor
}

proc status {args} {
	global IDX statusmessage

	if {[llength $args] != 0} {
		set statusmessage [join $args " "]
	}
	
	drawStatus $statusmessage
}

proc idx {row col} {
	global IDX BUFFER
	set c $IDX(ROWCOL)
	set r $IDX(ROWMAX)
	set str [format " L:%-9s C:%-4d[RESET]" "$row/[llength $BUFFER]" $col]
	set str [string range $str 0 [expr {$IDX(ROWCOLLEN)-1}]]

	# 80th column marker:
	if {$c > 80} {
		puts -nonewline [REV [GOTO $r 80] "|"]
	}
	puts -nonewline [REV [GOTO $r $c] $str [RESET]]
}

proc goto {row {col 1}} {
	puts -nonewline [doGoto $row $col]
}
proc doGoto {row {col 1}} {
	global IDX viewRow viewCol

	switch -- $row {
		"home" {set row 1}
		"cursor" {
			set row $viewRow
			set col $viewCol
		}
	}

	if {$row == "end"} {
		set row $IDX(ROWMAX)
	}
	return [GOTO $row $col]
}

proc clear {} {
	puts -nonewline [ESC_ 2J]
	flush stdout
}

proc clearline {} {
	return [ESC_ 2K]
}

proc hideCursor {} {
	puts -nonewline [ESC_ ?25l]
	flush stdout
}

proc showCursor {} {
	puts -nonewline [ESC_ ?25h]
	flush stdout
}

proc stripComments {data} {
	set ret ""
	foreach x [split $data "\n"] {
		set x [string trim $x]
		if {[string index $x 0] != "#"} {
			append ret "$x\n"
		}
	}
	return $ret
}

proc lineStart {line} {
	set homeCol [regexp -indices -inline {^\s*} $line]
	set homeCol [lindex [lindex $homeCol 0] 1]
	incr homeCol
}

proc currentFragment {{mode range}} {
	global BUFFER bufRow bufCol

	set line [lindex $BUFFER $bufRow]
	set idx [expr {$bufCol-1}]
	set s [string wordstart $line $idx]
	switch -- $mode {
		"range" {return	[list $s [expr {$bufCol-1}]]}
		"start" {return $s}
		"end"   {return [expr {$bufCol-1}]}
		"string" {return [string range $line $s [expr {$bufCol-1}]]}
	}
}

proc currentWord {{mode range}} {
	global BUFFER bufRow bufCol

	set line [lindex $BUFFER $bufRow]
	set idx [expr {$bufCol-1}]
	set s [string wordstart $line $idx]
	set n [string wordend $line $idx]
	switch -- $mode {
		"range" {return	[list $s [expr {$n-1}]]}
		"start" {return $s}
		"end"   {return [expr {$n-1}]}
		"string" {return [string range $line $s [expr {$n-1}]]}
	}
}

################################
# Autocomplete
################################
proc scanAutoComplete {word} {
	global BUFFER autoCompleteMatches tags IDX
	
	set autoCompleteMatches ""
	set startsWithWord "\\y$word\\w+"
	
	if {$word != ""} {
		foreach line $BUFFER {
			foreach x [
				regexp -inline -all $startsWithWord $line
			] {
				lappend autoCompleteMatches $x
			}
		}
		foreach x [
			regexp -inline -all $startsWithWord [array names tags]
		] {
			lappend autoCompleteMatches $x
		}
		set autoCompleteMatches [lsort -unique $autoCompleteMatches]
	}
	
	autoCompleteStatus
}

proc autoCompleteStatus {} {
	global autoCompleteMatches IDX
	
	if [llength $autoCompleteMatches] {
		set stat ""
		foreach n {1 2 3 4 5 6} m $autoCompleteMatches {
			if {
				([string length $stat]+[string length $m]+3) >
				$IDX(ROWCOL)
			} break
			
			if {$n != "" && $m != ""} {
				append stat "${n}:$m "
			}
		}
		status $stat
	} else {
		status ""
	}
}

proc substAutoComplete {{select 0}} {
	global BUFFER bufRow bufCol autoCompleteMatches
	
	if [llength $autoCompleteMatches] {
		set line [lindex $BUFFER $bufRow]
		
		set s [currentWord start]
		set n [currentWord end]
		
		set replacement [lindex $autoCompleteMatches $select]
		set line [string replace $line $s $n $replacement]
		
		registerUndo D $bufRow [expr {$n+1}] [string range $line $s $n]
		
		set BUFFER [lreplace $BUFFER $bufRow $bufRow $line]
		
		set bufCol [expr {$s+[string length $replacement]}]
		
		registerUndo I $bufRow $s $bufRow $bufCol
		
		set autoCompleteMatches [lreplace $autoCompleteMatches $select $select]
		lappend autoCompleteMatches $replacement
	}
}

################################
# Command handlers
################################
proc handleDelete {dir} {
	global BUFFER bufRow bufCol viewRow bufSelection
	global undoBuffer redoBuffer writable
	if {!$writable} return
	upvar 1 line line

	set line [lindex $BUFFER $bufRow]

	if [getSelection s_row_start s_col_start s_row_end s_col_end] {
		set copy_lines [lrange $BUFFER $s_row_start $s_row_end]
		set first_line [lindex $copy_lines 0]
		set last_line [lindex $copy_lines end]
		if {[llength $copy_lines] > 1} {
			lset copy_lines 0 [
				string range $first_line $s_col_start end
			]
			lset copy_lines end [
				string range $last_line 0 $s_col_end
			]
		} else {
			lset copy_lines 0 [
				string range [
					lindex $copy_lines 0
				] $s_col_start $s_col_end
			]
		}
		set BUFFER [lreplace $BUFFER $s_row_start $s_row_end [join [
			list [
				string range $first_line 0 [expr $s_col_start-1]
			] [
				string range $last_line [expr $s_col_end+1] end
			]
		] ""]]
		
		set bufRow $s_row_start
		set bufCol $s_col_start
		
		registerUndo D $s_row_start $s_col_start [join $copy_lines \n]
		set bufSelection {}
		
		handleRedraw forced
		return [join $copy_lines \n]
	}
	if {$dir == "-"} {
		if {$bufCol == 0 && $bufRow > 0} {
			set upRow [expr {$bufRow-1}]
			set line [lindex $BUFFER $upRow]
			set bufCol [string length $line]
			append line [lindex $BUFFER $bufRow]
			set BUFFER [lreplace $BUFFER $upRow $bufRow $line]
			incr viewRow -1
			set bufRow $upRow

			registerUndo D $bufRow $bufCol "\n"

			handleRedraw partial
			return
		}
		if {$bufCol < 1} return
		
		incr bufCol -1
	} else {
		if {$bufCol == [string length $line] && $bufRow < [llength $BUFFER]} {
			set downRow [expr {$bufRow+1}]
			append line [lindex $BUFFER $downRow]
			set BUFFER [lreplace $BUFFER $bufRow $downRow $line]

			registerUndo D $bufRow $bufCol "\n"

			handleRedraw partial
			return
		}
	}

	registerUndo D $bufRow $bufCol [string index $line $bufCol]

	set line [string replace $line $bufCol $bufCol]
	set BUFFER [lreplace $BUFFER $bufRow $bufRow $line]
	handleRedraw edit
	return
}

proc handleDeIndent {start end} {
	global usetabs tabstop

	for {set row $start} {$row <= $end} {incr row} {
		set line [lindex $::BUFFER $row]
		if [regexp {^(\s)} $line - whitespace] {
			if {$usetabs} {
				lset ::BUFFER $row [regsub {^\s} $line {}]
			} else {
				lset ::BUFFER $row [regsub "^(\t| {1,$tabstop})" $line {}]
			}
		}
	}
}

proc handleIndent {start end} {
	for {set row $start} {$row <= $end} {incr row} {
		lset ::BUFFER $row "[TAB][lindex $::BUFFER $row]"
	}
}

proc handleArrowSelect {cmd} {
	global bufSelection bufRow bufCol
	
	startSelection
	$cmd
	lset bufSelection 2 $bufRow
	lset bufSelection 3 [expr $bufCol-1]
	handleRedraw forced
}

proc handleLeftArrowSelect {{mode char}} {
	global bufSelection bufRow bufCol
	
	startSelection -1
	cursorLeft $mode
	lset bufSelection 2 $bufRow
	lassign $bufSelection rs cs rn cn
	if {$rn<$rs||($rs==$rn&&($cn<=$cs))} {
		lset bufSelection 3 $bufCol
	} else {
		lset bufSelection 3 [expr $bufCol-1]
	}
	handleRedraw forced
}

proc handleRightArrowSelect {{mode char}} {
	global bufSelection bufRow bufCol

	startSelection
	cursorRight $mode
	lset bufSelection 2 $bufRow
	lset bufSelection 3 [expr $bufCol-1]
	handleRedraw forced
}

proc syntaxHilight {line start} {
	global hilight IDX

	set matches ""
	set end [expr {$start+$IDX(COLMAX)-1}]
	foreach {pattern color} $hilight {
		set ps 0
		set pn 0
		foreach m [regexp -inline -all -indices -- $pattern $line] {
			foreach {s n} $m break
			lappend m $color
			if {$s <= $pn && $s >= $ps && $n <= $pn} {
				set matches [lreplace $matches end end $m]
			} else {
				lappend matches $m
			}
			set ps $s
			set pn $n
		}
	}

	set oldline [string range $line $start $end]
	set line {}
	set prev 0
	foreach m [lsort -integer -index 0 $matches] {
		foreach {s n color} $m break
		if {$s < $start} {
			set s 0
		} else {
			set s [expr {$s-$start}]
		}
		set n [expr {$n-$start}]
		if {$n > $end} {set n $end}

		if {$s < $prev} continue
		append line [string range $oldline $prev [expr {$s-1}]]
		set prev [expr {$n+1}]
		append line [ESC_ $color m]
		append line [string range $oldline $s $n]
		if {$n != $end} {
			append line [RESET]
		}
	}
	append line [string range $oldline $prev end]
	append line [RESET]

	return $line
}

proc un_ansi {data} {
	# --------------------------------------------------------------------------
	# (c) 2015 Stefan Finzel. From http://wiki.tcl.tk/9673
	# --------------------------------------------------------------------------
	set txt {}
	while {[string length $data]} {
		set match { }
		switch -regexp -- $data {
			"^\\x1b\]50;SetProfile=\\w+\a" {
				# special case for Iterm2 on Mac
				regexp "^\\x1b\]50;SetProfile=\\w+\a" $data match
			}
			{^\x1b(\[|\(|\))[;?0-9]*[0-9A-Za-z]} {
				regexp -- {^\x1b(\[|\(|\))[;?0-9]*[0-9A-Za-z]} $data match
				append txt "\n"
			}
			{^(.+?)\x1b} {
				regexp -- {^(.+?)\x1b} $data -> match
				# handle special escape sequences
				regsub -all -- {\\([\\\[\]])} $match {\1} raw_match
				append txt $raw_match
			}
			{^\x1b} {
				# do nothing
			}
			default {
				set match $data
				append txt $match
			}
		}
		set data [string range $data [string length $match] end]
	}
	
	return $txt
}

proc handleExec {} {
	global exechistory execShell filename env IDX keybuffer
	set ret 0
				
	drawStatus [join {
		"Special exported variables:" 
		"$f=this file, $s=selected text, $c=clipboard"
	} " "] 1
	set commandline [getInput "Exec:" exechistory]
	if {$commandline != ""} {
		historyAppend exechistory $commandline
		
		if {$execShell != ""} {
			set commandline [list $execShell << $commandline]
		}
		
		# Set special variables:
		set env(f) $filename
		set env(s) [getSelectionText]
		catch {set env(c) [clipboard get]}
		
		clear
		goto home
		hideCursor
		set result {}
		if {![catch {set pipe [open "|$commandline 2>@1"]}]} {
			while {![eof $pipe]} {
				set l [gets $pipe]
				lappend result $l
				puts $l
				flush stdout
			}
			catch {close $pipe}
		}
		set result [join $result \n]
		set ascii [un_ansi $result]
		
		if {[string trim $ascii] != ""} {
			drawStatus "Press ESC to exit this screen" 1
			keyInput {[C]opy to clipboard or [I]nsert to document?} {
				c {
					clipboard clear
					clipboard append -- [string trimright $ascii "\n"]
				}
				i {
					set keybuffer [string trimright $ascii "\n"]
					set ret 1
				}
			}
		}
		showCursor
	}
	status ""
	handleRedraw forced
	return $ret
}

proc handleSearch {} {
	global searchpattern searchcase bufSelection
	global BUFFER IDX viewRow bufRow bufCol

	if {$searchpattern != ""} {
		status "Search: $searchpattern"
		set bufSelection ""

		if {!$searchcase} {
			# Add (?i) to make search case insensitive:

			set n [regexp -inline -indices \
				{^\(\?[bceimnpqstwx]+?\)} $searchpattern]
			if {$n == ""} {
				set pattern "(?i)$searchpattern"
			} else {
				set n [lindex [lindex $n 0] 1]
				set opt [string range $searchpattern 2 [expr {$n-1}]]
				if {[regexp {i|c} $opt] == 0} {
					append opt i
				}
				set pattern "(?$opt)"
				append pattern [string range $searchpattern [expr {$n+1}] end]
			}
		} else {
			set pattern $searchpattern
		}

		if {[catch {lsearch -regexp [lrange $BUFFER \
			[expr {$bufRow+1}] end] $pattern} found]} {
			# Regexp error:
			status "regexp error: [lindex [split $found :] 1]"
		} else {
			set startRow $bufRow
			if {$found == -1} {
				set found [lsearch -regexp $BUFFER $pattern]
				if {$found != -1} {
					set bufRow $found
				}
			} else {
				incr bufRow $found
				incr bufRow
			}
			if {$found != -1} {
				set rowDiff [expr {$bufRow-$startRow}]
				incr viewRow $rowDiff
				if {$viewRow < 0 || $viewRow > $IDX(ROWMAX)} {
					set viewRow 5
				}

				set C [regexp -indices -inline -- $pattern \
					[lindex $BUFFER $bufRow]]
				set bufCol [lindex [lindex $C 0] 0]
				if {$bufRow < $viewRow} {
					set viewRow 0
				}
			} else {
				status "Search: $searchpattern (not found!)"
			}
		}
	}
	handleRedraw
}

proc handleNewline {} {
	global BUFFER viewRow bufRow bufCol
	global undoBuffer redoBuffer writable keybuffer
	if {!$writable} return

	# The getSpaces is for auto-indenting:
	set line [lindex $BUFFER $bufRow]
	set newline [getSpaces $line]

	set currline [string range $line 0 [expr {$bufCol - 1}]]
	set line [string range $line $bufCol end]
	set BUFFER [lreplace $BUFFER $bufRow $bufRow $currline]

	set row $bufRow
	incr bufRow
	set col $bufCol

	if {$keybuffer == "" && [regexp {^\s} $line] == 0} {
		set len [string length $newline]
		append newline $line
		set bufCol $len
	} else {
		set newline $line
		set bufCol 0
	}
	set BUFFER [linsert $BUFFER $bufRow $newline]

	registerUndo I $row $col $bufRow $bufCol

	if {[string first "\n" $keybuffer] < 0} {
		handleRedraw partial
	}
	incr viewRow
}

proc TAB {} {
	global usetabs tabstop
	if {$usetabs} {
		return "\t"
	}
	return [string repeat " " $tabstop]
}

proc handleInsert {} {
	global BUFFER bufRow bufCol viewRow tabCompleteWord
	global undoBuffer redoBuffer writable insertToSelection
	if {!$writable} return
	upvar 1 printbuffer printbuffer
	
	if {$printbuffer == "\t"} {
		if [getSelection s_row_start s_col_start s_row_end s_col_end] {
			lset ::bufSelection 1 0
			lset ::bufSelection 3 [string length [lindex $BUFFER $s_row_end]]
			
			handleIndent $s_row_start $s_row_end
			registerUndo T $s_row_start $s_row_end
			return
		} else {
			# Tab completion:
			if {$tabCompleteWord == ""} {
				set tabCompleteWord [currentFragment string]
				if [regexp {\w+} $tabCompleteWord tabCompleteWord] {
					scanAutoComplete $tabCompleteWord
				} else {
					set tabCompleteWord ""
				}
			}
			if {$tabCompleteWord != ""} {
				substAutoComplete
				autoCompleteStatus
				return
			}
		}
		set printbuffer [TAB]
	} else {
		set tabCompleteWord ""
	}
	
	set newstring [getSpaces $printbuffer][string trimleft $printbuffer]
	
	if [llength $::bufSelection] {
		set insertToSelection 1
		handleDelete -
	}
	set line [lindex $BUFFER $bufRow]
	set line [stringInsert $line $bufCol $newstring]

	set BUFFER [lreplace $BUFFER $bufRow $bufRow $line]
	set len [string length $printbuffer]
	set col $bufCol
	incr bufCol $len
	registerUndo I $bufRow $col $bufRow $bufCol

	set fragment [currentFragment string]
	if [regexp {\w+} $fragment fragment] {
		scanAutoComplete $fragment
	}
}

proc startSelection {{colAdjust 0}} {
	global bufSelection bufRow bufCol
	if {![llength $bufSelection]} {
		set bufSelection [list \
			$bufRow [expr $bufCol+$colAdjust] \
			$bufRow [expr $bufCol+$colAdjust]
		]
	}
}

proc fixViewRow {oldBufRow} {
	if {abs($::bufRow-$oldBufRow) < $::IDX(ROWMAX)} {
		incr ::viewRow [expr {$::bufRow-$oldBufRow}]
	} else {
		set ::viewRow [expr {$::IDX(ROWMAX)/2}]
	}
}

proc undo {cmd sRow sCol args} {
	global BUFFER IDX bufRow bufCol viewRow

	set oldBufRow $bufRow
	set bufRow $sRow
	set bufCol $sCol
	set oldline [lindex $BUFFER $sRow]
	set line [string range $oldline 0 [expr $bufCol - 1]]
	set ret ""

	switch -exact -- $cmd {
		"C" {
			lassign $args end
			handleBlockUncomment $sRow $end
			set ret "~C $sRow 0 $end"
		}
		"~C" {
			lassign $args end
			handleBlockComment $sRow $end
			set ret "C $sRow 0 $end"
		}
		"T" {
			lassign $args end
			handleDeIndent $sRow $end
			set ret "~T $sRow 0 $end"
		}
		"~T" {
			lassign $args end
			handleIndent $sRow $end
			set ret "T $sRow 0 $end"
		}
		"D" {
			set txt [lindex $args 0]
			set txt [split $txt "\n"]
			set endline [string range $oldline $bufCol end]

			set line "$line[lindex $txt 0]"
			if {[llength $txt] > 1} {
				set BUFFER [lreplace $BUFFER $bufRow $bufRow $line]
				foreach x [lrange $txt 1 end-1] {
					incr bufRow
					set BUFFER [linsert $BUFFER $bufRow $x]
				}
				incr bufRow
				set last [lindex $txt end]
				set endline "$last$endline"
				set BUFFER [linsert $BUFFER $bufRow $endline]
				set len [string length $last]
				set bufCol $len
			} else {
				append line [string range $oldline $bufCol end]
				set BUFFER [lreplace $BUFFER $bufRow $bufRow $line]
				set len [string length [lindex $txt 0]]
				incr bufCol $len
			}
			set ret [list I $sRow $sCol $bufRow $bufCol]
		}
		"I" {
			foreach {nRow nCol} $args break
			set endline [lindex $BUFFER $nRow]

			if {$sRow == $nRow} {
				set deleted [string range $oldline $sCol [expr {$nCol-1}]]
			} else {
				set deleted [string range $oldline $sCol end]
				for {set x [expr {$sRow+1}]} {$x < $nRow} {incr x} {
					append deleted "\n"
					append deleted [lindex $BUFFER $x]
				}
				append deleted "\n"
				append deleted [string range $endline 0 [expr {$nCol-1}]]
			}

			append line [string range $endline $nCol end]
			set BUFFER [lreplace $BUFFER $sRow $nRow $line]
			set ret [list D $sRow $sCol $deleted]
		}
	}

	fixViewRow $oldBufRow
	handleRedraw forced
	return $ret
}

proc handleUndo {from to} {
	global undoBuffer redoBuffer
	if {[llength [set $from]] > 0} {
		set op [lindex [set $from] end]
		set $from [lreplace [set $from] end end]
		lappend $to [eval "undo $op"]
		status ""
	} else {
		status "$from empty."
		flush stdout
	}
}

proc registerUndo {type args} {
	global undoBuffer redoBuffer
	set last [lindex $undoBuffer end]
	set lastarg [lrange $last 1 end]
	set last [lindex $last 0]

	set redoBuffer ""

	switch -exact -- $type {
		"T" - "~T" - "C" - "~C" {
			lassign $args start end
			lappend undoBuffer [list $type $start 0 $end]
		}
		"I" {
			foreach {sRow sCol nRow nCol} $args break
			if {$last == $type} {
				foreach {lsRow lsCol lnRow lnCol} $lastarg break
				if {$sRow == $lnRow && $sCol == $lnCol} {
					set sRow $lsRow
					set sCol $lsCol
					set undoBuffer [lreplace $undoBuffer end end]
				}
			}
			lappend undoBuffer [list $type $sRow $sCol $nRow $nCol]
		}
		"D" {
			foreach {sRow sCol txt} $args break
			if {$last == $type} {
				foreach {lsRow lsCol ltxt} $lastarg break
				if {$sRow == $lsRow} {
					if {$sCol == $lsCol} {
						set txt "$ltxt$txt"
						set undoBuffer [lreplace $undoBuffer end end]
					} elseif {$sCol+1 == $lsCol} {
						append txt $ltxt
						set undoBuffer [lreplace $undoBuffer end end]
					}
				} elseif {$sRow+1 == $lsRow && $txt == "\n"} {
					append txt $ltxt
					set undoBuffer [lreplace $undoBuffer end end]
				}
			}
			lappend undoBuffer [list $type $sRow $sCol $txt]
		}
	}
}

proc handlePageUp {} {
	global IDX bufRow bufCol viewRow

	set size [expr {$IDX(ROWMAX) - 1}]
	if {$bufRow < $size} {
		set bufRow	0
		set viewRow 1
	} else {
		incr bufRow	-$size
		incr viewRow -$size
	}
	endLine
	uplevel 1 updateSelection
	handleRedraw
}

proc handlePageDown {} {
	global IDX BUFFER bufRow bufCol viewRow

	set size [expr {$IDX(ROWMAX) - 1}]
	incr bufRow	$size
	incr viewRow $size
	if {$bufRow >= [llength $BUFFER]} {
		set viewRow [llength $BUFFER]
		set bufRow	[expr {$viewRow - 1}]
	}
	endLine
	uplevel 1 updateSelection
	handleRedraw
}

proc handleGotoLine {n} {
	global bufRow viewRow IDX BUFFER

	set oldBufRow $bufRow
	set bufRow [expr {$n-1}]
	set len [llength $BUFFER]
	if {$bufRow >= $len} {
		set bufRow [expr {$len-1}]
	}
	fixViewRow $oldBufRow
	handleRedraw
}

proc goToDef {} {
	global tags tags_root filename IDX comeFrom

	set tag [currentWord string]

	if [info exists tags($tag)] {
		if {[llength $tags($tag)] > 2} {
			set selection {}
			foreach {sourceFile searchSpec} $tags($tag) {
				set searchSpec [string trim $searchSpec {\";/ \t^$}]
				if {$searchSpec != ""} {
					lappend selection "$sourceFile: $searchSpec"
				}
			}
			set ss [selectMenu $selection 0]
			if {$ss >= 0} {
				set ss [expr {$ss*2}]
				set defFile [lindex $tags($tag) $ss]
				set searchSpec [lindex $tags($tag) [expr $ss+1]]
			} else {
				return
			}
			flush stdout
		} else {
			status "Going to definition.."
			flush stdout
			lassign $tags($tag) defFile searchSpec
		}

		set thisDir [pwd]
		set redir ">&@ stdout <@ stdin"
		set myself "$redir {[info nameofexecutable]} {[info script]}"
		set command ""

		if [regexp {^(\d+);\"$} $searchSpec - lineNumber] {
			set command [list -G $lineNumber]
		}
		if [regexp {^/\^(.+)\$/;\"$} $searchSpec - literal] {
			set command [list -F "(?c)^[regexpSafe $literal]\$"]
		}

		if {$command != ""} {
			lappend command -define comeFrom "$filename > "

			cd $tags_root
			if [catch "exec $myself {$defFile} $command" err] {
				puts $err
			}
			cd $thisDir

			catch {
				# Set raw mode again bacause the exiting program
				# may have reset it to canonical mode:
				exec stty raw -echo  
	
				# Set window title:
				puts -nonewline [WINDOW_TITLE "$comeFrom$filename"]
				# Enable mouse reporting:
				puts -nonewline [ESC_ ?1002h][ESC_ ?1015h]
			}

			read stdin
			status ""
			handleRedraw forced
		}
	}
}

proc handleReload {{msg "Revert unsaved changes?"}} {
	global modified
	if {!$modified || [getConfirmation $msg]} {
		openFile
		set modified 0
		handleRedraw forced
		status "Reloaded"
	} else {
		status "Aborted"
	}
	flush stdout
}

proc getSelection {args} {
	set s [normalizeSelection]
	if [llength $s] {
		foreach up $args var {a b c d} {
			upvar 1 $up $var
		}
		lassign $s a b c d
		return 1
	}
	return 0
}

proc getSelectionText {} {
	global BUFFER
	
	set copy_lines {}
	
	if [getSelection s_row_start s_col_start s_row_end s_col_end] {
		set copy_lines [lrange $BUFFER $s_row_start $s_row_end]
		if {[llength $copy_lines] > 1} {
			lset copy_lines 0 [
				string range [
					lindex $copy_lines 0
				] $s_col_start end
			]
			lset copy_lines end [
				string range [
					lindex $copy_lines end
				] 0 $s_col_end
			]
		} else {
			lset copy_lines 0 [
				string range [
					lindex $copy_lines 0
				] $s_col_start $s_col_end
			]
		}
	}
	return [join $copy_lines \n]
}

proc handleBlockComment {start end} {
	# Find smallest number of whitespace to align our comment to:
	set comment_col infinity
	for {set row $start} {$row <= $end} {incr row} {
		set line [lindex $::BUFFER $row]
		set this_col [lineStart $line]
		if {$this_col < $comment_col} {
			set comment_col $this_col
		}
	}
	
	set pre_comment_col [expr {$comment_col-1}]
	for {set row $start} {$row <= $end} {incr row} {
		set line [lindex $::BUFFER $row]
		set line [join [list [
			string range $line 0 $pre_comment_col
		] "$::block_comment_symbol " [
			string range $line $comment_col end
		]] ""]
		lset ::BUFFER $row $line
	}
}

proc handleBlockUncomment {s_row_start s_row_end} {
	set re "^\\s*([regexpSafe $::block_comment_symbol] )"
	for {set row $s_row_start} {$row <= $s_row_end} {incr row} {
		set line [lindex $::BUFFER $row]
		
		if [regexp -indices -- $re $line - comment] {
			lassign $comment comment_s comment_n
			lset ::BUFFER $row [string replace $line $comment_s $comment_n ""]
		}
	}
}

proc toggleBlockComment {} {
	global block_comment_symbol bufSelection BUFFER bufCol bufRow;
	
	if {![getSelection s_row_start s_col_start s_row_end s_col_end]} {
		set s_row_start $bufRow
		set s_row_end $bufRow
		set s_col_start 0
		set s_col_end [string length [lindex $BUFFER $bufRow]]
	}
			
	# Check if we're commenting or uncommenting:
	set uncommenting 1
	set re "^\\s*([regexpSafe $block_comment_symbol] )"
	
	for {set row $s_row_start} {$row <= $s_row_end} {incr row} {
		if {![regexp -- $re [lindex $BUFFER $row]]} {
			set uncommenting 0
			break
		}
	}
	
	if {$uncommenting} {
		# Looks like we're uncommenting:
		handleBlockUncomment $s_row_start $s_row_end
		registerUndo ~C $s_row_start $s_row_end
	} else {
		# We're commenting:
		handleBlockComment $s_row_start $s_row_end
		registerUndo C $s_row_start $s_row_end
	}

	if [llength $bufSelection] {
		lset bufSelection 1 0
		lset bufSelection 3 [string length [lindex $BUFFER $s_row_end]]
	}
	
	return 1
}

proc suspend {} {
	global filename searchpattern modified
	global searchhistory gotohistory
	global viewRow viewCol bufRow bufCol
	global undoBuffer redoBuffer BUFFER

	# Don't save anything if BUFFER is not modified:
	if {$modified} {
		saveFile
		set suspendFile $filename.tsuspend

		set f [open $suspendFile w+]
		puts $f "ted suspend"
		foreach x {
			filename
			searchpattern
			viewRow viewCol bufRow bufCol
		} {
			puts $f [list $x [set $x]]
		}
		foreach x {undoBuffer redoBuffer searchhistory gotohistory} {
			puts $f "$x {[join [string map {\n \000} [set $x]] \n]}"
		}
		puts $f "BUFFER {[join $BUFFER \n]}"
		close $f
	}
	doExit
}

proc resume {data} {
	global filename searchpattern modified
	global searchhistory gotohistory
	global viewRow viewCol bufRow bufCol
	global undoBuffer redoBuffer BUFFER
	set modified 1
	set ted ""

	foreach {var val} $data {
		if {$var == "ted" || $ted == "suspend"} {
			if {$var == "BUFFER"} {
				set $var [split $val "\n"]
			} elseif {
				$var == "undoBuffer"    ||
				$var == "redoBuffer"    ||
				$var == "searchhistory" ||
				$var == "gotohistory"
			} {
				set $var "[string map {\000 \n} [split $val \n]]"
			} else {
				set $var $val
			}
		}
	}
	return $ted
}

proc cursorDown {{mode "normal"}} {
	global bufRow bufCol BUFFER IDX viewCol viewRow
	
	if {$bufRow < ([llength $BUFFER] - 1)} {
		if {[getCol $bufRow $bufCol] > $IDX(COLMAX)} {
			set tmp $bufCol
			set bufCol 0
			handleRedraw line
			set bufCol $tmp
		}
		
		incr bufRow 1
		incr viewRow 1
		
		if {$mode != "normal"} {
			set bufCol 0
			# handleRedraw line
		}
	}
	endLine
}

proc cursorUp {{mode "normal"}} {
	global bufRow bufCol BUFFER IDX viewCol viewRow

	if {$bufRow > 0} {
		if {[getCol $bufRow $bufCol] > $IDX(COLMAX)} {
			set tmp $bufCol
			set bufCol 0
			handleRedraw line
			set bufCol $tmp
		}
		incr bufRow -1
		incr viewRow -1
		
		if {$mode != "normal"} {
			set bufCol [string length [lindex $BUFFER $bufRow]]
			# handleRedraw line
		}
	}
	endLine
}

proc cursorLeft {{mode char}} {
	global bufRow bufCol BUFFER IDX viewCol viewRow

	if {$mode == "char"} {
		if {$bufCol > 0} {
			incr bufCol -1
			return line
		} else {
			cursorUp continued
			return full
		}
	} elseif {$mode == "word"} {
		set words [regexp -inline -indices -all {\S+} [lindex $BUFFER $bufRow]]
		
		foreach w [lreverse $words] {
			lassign $w start end
			
			if {$bufCol > $end} {
				set bufCol $start
				return line
			}
		}
		cursorUp continued
		if {$bufRow > 0 && [string length [lindex $BUFFER $bufRow]]} {
			cursorLeft word
		}
		return full
	}
}

proc cursorRight {{mode char}} {
	global bufRow bufCol BUFFER IDX viewCol viewRow

	if {$mode == "char"} {
		if {$bufCol < [string length [lindex $BUFFER $bufRow]]} {
			incr bufCol 1
			return line
		} else {
			cursorDown continued
			return full
		}
	} elseif {$mode == "word"} {
		set line [lindex $BUFFER $bufRow]
		set words [regexp -inline -indices -all {\S+} $line]
		
		foreach w $words {
			lassign $w start end
			
			if {$bufCol < $start} {
				set bufCol $start
				return line
			}
		}
		cursorDown continued
		return full
	}
}

proc updateSelection {} {
	global bufSelection bufRow bufCol
	
	if [llength $bufSelection] {
		lset bufSelection 3 $bufCol
		lset bufSelection 2 $bufRow
		uplevel 1 {
			set selecting 1
		}
		return 1
	}
	return 0
}

################################
# Key bindings
################################
proc handleEscapes {} {
uplevel 1 {
	global bufSelection
	set seq ""
	set found 0
	set selecting 0
	while {[set ch [readbuf]] != ""} {
		append seq $ch

		switch -exact -- $seq {
			"1" - "2" - "3" -
			"4" - "5" - "6" { ;# Alt-1,Alt-2..Alt-6 (select autocomplete)
				substAutoComplete [expr {$seq-1}]
				handleRedraw edit
				set found 1; break
			}
			"`" { ;# hack to handle unavailability of Alt-1 on ubuntu:
				substAutoComplete 0
				handleRedraw edit
				set found 1; break
			}
			";" { ;# toggle tab guide
				if {$::tabGuide} {
					set ::tabGuide 0
					status "Tab Guide: off"
				} else {
					set ::tabGuide 1
					status "Tab Guide: on"
				}
				handleRedraw forced
				set found 1; break
			}
			"\[A" { ;# Cursor Up
				cursorUp
				handleRedraw
				set found 1; break
			}
			"\[B" { ;# Cursor Down
				cursorDown
				handleRedraw
				set found 1; break
			}
			"\[C" { ;# Cursor Right
				handleRedraw [cursorRight]
				set found 1; break
			}
			"\[D" { ;# Cursor Left
				handleRedraw [cursorLeft]
				set found 1; break
			}
			"OH" -
			"\[H" -
			"\[7~" -
			"\[1~" { ;# home
				set line [lindex $BUFFER $bufRow]
				set homeCol [lineStart $line]
				if {$bufCol != $homeCol} {
					set bufCol $homeCol
				} else {
					set bufCol 0
				}
				updateSelection
				handleRedraw line
				set found 1; break
			}
			"\[3~" { ;# delete
				handleDelete +
				set found 1; break
			}
			"OF" -
			"\[F" -
			"\[K" -
			"\[8~" -
			"\[4~" { ;# end
				set bufCol [string length [lindex $BUFFER $bufRow]]
				updateSelection
				handleRedraw line
				set found 1; break
			}
			"\[5~" { ;# 5 Prev screen
				handlePageUp
				set found 1; break
			}
			"\[6~" { ;# 6 Next screen
				handlePageDown
				set found 1; break
			}
			"OR" -
			"\[13~" { ;# F3
				handleSearch
				set found 1; break
			}
			"\[Z" { ;# shift-tab
				# De-indent
				if [getSelection s_row_start s_col_start s_row_end s_col_end] {
					lset bufSelection 1 0
					lset bufSelection 3 [
						string length [lindex $BUFFER $s_row_end]
					]
					set selecting 1
				} else {
					set s_row_start $bufRow
					set s_row_end $bufRow
				}
				handleDeIndent $s_row_start $s_row_end
				registerUndo ~T $s_row_start $s_row_end
				handleRedraw forced
				set found 1; break
			}
			"/" { ;# alt-/
				# Block comment/uncomment
				if [toggleBlockComment] {
					handleRedraw forced
				}
				set selecting 1; set found 1; break
			}
			"\[1;5B" { ;# ^-down arrow
				goToDef
				set found 1; break
			}
			"\[1;5A" { ;# ^-up arrow
			            # Return from Def
			            # This is basically the same as quit but
			            # only when we come from another file.

				global comeFrom
				if {$comeFrom != ""} {
					saveFile
					doExit
				}
				set found 1; break
			}
			"\[1;2A" { ;# shift-up arrow
				handleArrowSelect cursorUp
				set selecting 1; set found 1; break
			}
			"\[1;2B" { ;# shift-down arrow
				handleArrowSelect cursorDown
				set selecting 1; set found 1; break
			}
			"\[1;2C" { ;# shift-right arrow
				handleRightArrowSelect
				set selecting 1; set found 1; break
			}
			"\[1;2D" { ;# shift-left arrow
				handleLeftArrowSelect
				set selecting 1; set found 1; break
			}
			"[1;5D" { ;# ^-left arrow
				handleRedraw [cursorLeft word]
				set found 1; break	
			}
			"[1;5C" { ;# ^-right arrow
				handleRedraw [cursorRight word]
				set found 1; break	
			}
			"[1;6D" { ;# ^-shift-left arrow
				handleLeftArrowSelect word
				set selecting 1; set found 1; break	
			}
			"[1;6C" { ;# ^-shift-right arrow
				handleRightArrowSelect word
				set selecting 1; set found 1; break
			}
			"\[24~" { ;# F12
				global debughistory
				set cmd [getInput "Debug:" debughistory]
				if {$cmd != ""} {
					historyAppend debughistory $cmd
					clear
					goto home
					hideCursor
					puts [uplevel #0 $cmd]
					flush stdout
					waitForESC
					showCursor
					handleRedraw forced
				}
				status ""
				flush stdout
				set found 1; break
			}
			"OQ" { ;# F2
				if [handleExec] {
					return 1
				}
				set found 1; break
			}
		}
		if [regexp {\[(\d+);(\d+);(\d+)M} $seq -> cmd x y] {
			# Mouse events:
			global bufRow bufCol viewRow IDX bufSelection
			global mousewheelSpeed mouseMoved clickCount
			
			set mouseRow [expr {$y+$bufRow-$viewRow}]
			set mouseCol [colFromViewCol $mouseRow [expr {$x-1}]]
			set bufLen [expr {[llength $BUFFER]-1}]
			if {$mouseRow > $bufLen} {
				incr y [expr {$bufLen-$mouseRow}]
				set mouseRow $bufLen
			}
			
			switch $cmd {
				97 { ;# mousewheel down
					if {$bufRow < ([llength $BUFFER] + $viewRow - $IDX(ROWMAX))} {
						incr viewRow -$mousewheelSpeed
					}
					for {set x 0} {$x < $mousewheelSpeed} {incr x} cursorDown
					handleRedraw
					set found 1; break
				}
				96 { ;# mousewheel up
					if {$bufRow > $viewRow} {
						incr viewRow $mousewheelSpeed
					}
					for {set x 0} {$x < $mousewheelSpeed} {incr x} cursorUp
					handleRedraw
					set found 1; break
				}
				32 { ;# mouse selection start
					set bufSelection [
						list $mouseRow $mouseCol $mouseRow $mouseCol
					]
					set mouseMoved 0
					set selecting 1;set found 1; break
				}
				35 { ;# mouse selection end
					set viewRow $y
					set bufRow $mouseRow
					set bufCol $mouseCol
					
					if {!$mouseMoved} { ;# then don't select anything
						incr clickCount
						set selecting 0
						set bufSelection {}
						
						if {$clickCount == 2} { ;# double click!
							# Note: clickCount is reset
							# every second in edittext
							
							set bufSelection [list \
								$bufRow [currentWord start] \
								$bufRow [currentWord end]
							]
							status $bufSelection
							flush stdout
							set selecting 1
						}
						
						handleRedraw forced
					} else {
						set selecting 1
						lset bufSelection 2 $mouseRow
						lset bufSelection 3 $mouseCol
						handleRedraw forced
					}
					set found 1; break
				}
				64 { ;# mouse selection move
					lset bufSelection 2 $mouseRow
					lset bufSelection 3 $mouseCol
					set mouseMoved 1
					handleRedraw forced
					set selecting 1;set found 1; break
				}
			}
		}
	}
	if {!$found} {
		status "Unhandled sequence:$seq ([string length $seq])"
		flush stdout
	}
	if {!$selecting} {
		if [llength $bufSelection] {
			set bufSelection {}
			handleRedraw forced
		}
	}
}
return 0
}

proc handleControls {} {
global statusmessage keybuffer bufSelection
set old_statusmessage $statusmessage
uplevel 1 {
	# Control chars start at a == \u0001 and count up.
	switch -exact -- $char {
		\u001a { ;# ^z - undo
			handleUndo undoBuffer redoBuffer
		}
		\u0019 { ;# ^y - redo
			handleUndo redoBuffer undoBuffer
		}
		\u001c { ;# ^| - dump undoBuffer (for dubugging)
			global undoBuffer redoBuffer filename tags gotohistory
			clear
			goto home
			puts [string trim $::ABOUT]
			
			puts [REV "Info:" [RESET]]
			puts "File: $filename"
			puts "Selection: [normalizeSelection]"
			puts "Autocomplete: $::autoCompleteMatches"
			
			puts [REV "Settings:" [RESET]]
			puts "execShell: $::execShell"
			puts "tabstop: $::tabstop"
			puts "usetabs: $::usetabs"
			puts "searchcase: $::searchcase"
			puts "mousewheelSpeed: $::mousewheelSpeed"
			puts "tabGuide: $::tabGuide"
			puts "tabGuideChar: $::tabGuideChar"
			
			puts [REV "Undo buffer ([llength $undoBuffer] actions):" [RESET]]
			if {[llength $undoBuffer] > 5} {puts ...}
			foreach x [lrange $undoBuffer end-5 end] {
				puts $x
			}
			puts [REV "Redo buffer ([llength $redoBuffer] actions):" [RESET]]
			if {[llength $redoBuffer] > 5} {puts ...}
			foreach x [lrange $redoBuffer end-5 end] {
				puts $x
			}
			puts [REV "Goto history ([llength $gotohistory]):" [RESET]]
			if {[llength $gotohistory] > 5} {puts ...}
			foreach x [lrange $gotohistory end-5 end] {
			  puts $x
			}
			idx $viewRow $viewCol
			
			waitForESC

			status ""
			handleRedraw forced
		}
		\u0011 { ;# ^q - quit
			return done
		}
		\u0001 { ;# ^a - beginning of line
			set bufCol 0
			handleRedraw line
		}
		\u0018 { ;# ^x - cut selection
			if [llength $::bufSelection] {
				clipboard clear
				clipboard append -- [handleDelete -]
				update
			}
		}
		\u0003 { ;# ^c - copy selection
			set copy_lines [getSelectionText]
			if {$copy_lines != ""} {
				clipboard clear
				clipboard append -- $copy_lines
				update
			}
		}
		\u0004 { ;# ^d - delete line(s)
			if {$bufRow < [llength $BUFFER] && $writable} {
				if [getSelection s_row_start s_col_start s_row_end s_col_end] {
					set oldlines [lrange $BUFFER $s_row_start $s_row_end]
					set BUFFER [lreplace $BUFFER $s_row_start $s_row_end]
					
					set bufRow $s_row_start
					set bufCol 0
	
					registerUndo D $s_row_start 0 "[join $oldlines \n]\n"
	
					if {$bufRow >= [llength $BUFFER] && $bufRow > 0} {
						set bufRow [expr {[llength $BUFFER]-1}]
					}
					set viewRow $bufRow
					set bufSelection {}
					
					handleRedraw forced
				} else {
					set oldline [lindex $BUFFER $bufRow]
					set BUFFER [lreplace $BUFFER $bufRow $bufRow]
	
					registerUndo D $bufRow 0 "$oldline\n"
	
					handleRedraw partial
	
					if {$bufRow >= [llength $BUFFER] && $bufRow > 0} {
						incr bufRow -1
						incr viewRow -1
						handleRedraw partial
					}
				}
			}
		}
		\u0005 { ;# ^e - end of line
			set bufCol [string length [lindex $BUFFER $bufRow]]
			handleRedraw line
		}
		\u0006 { ;# ^f - find/search
			global searchpattern searchhistory
			set searchpattern [getInput "Search:" searchhistory]
			historyAppend searchhistory $searchpattern
			handleSearch
		}
		\u0007 { ;# ^g - goto line
			global gotohistory
			set n [getInput "Goto Line:" gotohistory]
			set n [regexp -inline {\S+} $n]

			# Support here index for bookmarking.
			if {$n == "here"} {
				set n [expr {$bufRow+1}]
			}

			if [string is integer -strict $n] {
				set theLine [lindex $BUFFER [expr {$n-1}]]
				historyAppend gotohistory "$n : [string trim $theLine]"

				handleGotoLine $n
			} else {
				status ""
			}
			handleRedraw
		}
		\u000f { ;# ^o - page up
			handlePageUp
		}
		\u0010 { ;# ^p - page down
			handlePageDown
		}
		\u0013 { ;# ^s - save file
			saveFile
		}
		\u0012 { ;# ^r - reload
			handleReload
		}
		\u0017 { ;# ^w - suspend
			# Suspend saves the current BUFFER along with most other
			# internal variables like the undo and redo buffers to a
			# file which can be later opened to resume editing.
			# Suspend does not save the original file.
			suspend
		}
		\u0008 -
		\u007f { ;# ^h && backspace ?
			handleDelete -
		}
		\u001b { ;# ESC - handle escape sequences
			drainStdin
			if [handleEscapes] return
		}
		\u0016 { ;# ^v - paste
			catch {set keybuffer [clipboard get]}
			return ;# prevent rate limiter from nuking the keybuffer
		}
		default {
			binary scan $char c ch
			status "Unhandled control character:[format 0x%x $ch]"
			flush stdout
		}
	}
	
	# Rate limiter:
	set firstEsc [string last [ESC] $keybuffer]
	if {$firstEsc == -1} {
		set keybuffer ""
	} else {
		set keybuffer [string range $keybuffer $firstEsc end]
	}
}
# Reset autocomplete:
global tabCompleteWord autoCompleteMatches
set tabCompleteWord ""
if {$autoCompleteMatches != ""} {
	set autoCompleteMatches ""
	if {$statusmessage == $old_statusmessage} {
		status ""
		flush stdout
	}
}
}

################################
# Rendering engine
################################
proc linerange {row} {
	global BUFFER tabstop bufCol

	set col 0
	set line ""
	set L [split [lindex $BUFFER $row] "\t"]
	set last [lindex $L end]
	set L [lrange $L 0 end-1]
	foreach c $L {
		incr col [string length $c]
		set n [expr {$tabstop-$col%$tabstop}]
		incr col $n

		# align to tabs:
		append line $c
		append line [string repeat " " $n]
	}
	append line $last
}

proc normalizeSelection {} {
	global bufSelection
	
	if [llength $bufSelection] {
		lassign $bufSelection row1 col1 row2 col2
		if {$row1 == $row2} {
			if {$col1 > $col2} {
				return [list $row2 $col2 $row1 $col1]
			}
			return [list $row1 $col1 $row2 $col2]
		}
		if {$row1 > $row2} {
			return [list $row2 $col2 $row1 $col1]
		}
		return [list $row1 $col1 $row2 $col2]
	}
	return {}
}

proc drawSelection {row line selection_range} {
	set drawBuffer ""
	
	if [llength $selection_range] {
		lassign $selection_range \
			s_row_start s_col_start \
			s_row_end s_col_end
						
		if {$s_row_start <= $row && $row <= $s_row_end} {
			if {$row != $s_row_start} {
				set s_col_start 0
			}
			if {$row != $s_row_end} {
				set s_col_end [expr {[string length $line]-1}]
			}
			
			# Save cursor position:
			append drawBuffer [SAVE]
			
			if {$row == $s_row_start || $row == $s_row_end} {
				# Move to start of line:
				append drawBuffer "\r"
				# Move to start of selection:
				if {$s_col_start > 0} {
					append drawBuffer [RIGHT [
						expr {[getCol $row $s_col_start]-1}
					]]
				}
			}
			
			# Output reverse text:
			append drawBuffer [ESC_ "$::bg(white);$::fg(black);$::style(bright)m"]
			append drawBuffer [string range $line [
				expr {[
					getCol $row $s_col_start
				]-1}
			] [
				expr {[
					getCol $row $s_col_end end
				]-1}
			]]
			append drawBuffer [RESET]
			
			# Restore cursor:
			append drawBuffer [UNSAVE]
		}
	}
	return $drawBuffer
}

proc drawTabGuides {row {viewline "__NO_MATCH__"}} {
	global BUFFER tabstop tabGuide fg style tabGuideChar tabGuideColor
	set drawBuffer ""
	
	if {$tabGuide} {
		set partial_tabstop [expr {$tabstop-1}]
		set line [lindex $BUFFER $row]
		set tabmatch [regexp -inline {^\t+} $line]
		set tabs [string length [lindex $tabmatch 0]]
		
		if {$tabs > 0} {
			if {$viewline == "__NO_MATCH__"} {
				set viewline [linerange $row]
			}
		
			append drawBuffer [SAVE]
			append drawBuffer "\r"
			append drawBuffer [RIGHT $tabstop]
			while {[incr tabs -1] > 0} {
				append drawBuffer [
					ESC_ $tabGuideColor m $tabGuideChar [RESET]
				]
				append drawBuffer [RIGHT $partial_tabstop]
			}
			
			append drawBuffer [UNSAVE]
		}
	}
	return $drawBuffer
}
						
proc handleRedraw {{mode "full"}} {
	# Valid modes are: full(default), line, edit, partial, forced

	global IDX BUFFER tabstop viewRow viewCol bufRow bufCol bufSelection

	# Buffer-up everything so we can manage outputs better:
	set drawBuffer ""
	
	set selection_range [normalizeSelection]

	# Constrain current view idx
	set inview 1
	if {$viewRow <= 1} {set viewRow 1}
	if {$viewRow >= ($IDX(ROWMAX) - 1)} {
		set viewRow [expr {$IDX(ROWMAX) - 1}]
		set inview 0
	}

	set startRow [expr {$bufRow + 1 - $viewRow}]
	if {$mode == "partial" && $inview} {
		set start $bufRow
		append drawBuffer [doGoto $viewRow 1]
	} else {
		set start $startRow
		append drawBuffer [doGoto home]
	}
	set row $bufRow

	if {
		($mode == "full" && $IDX(ROWLAST) != $startRow) ||
		$mode == "partial" ||
		$mode == "forced"
	} {
		# Add display size to get end points
		set endRow [expr {$startRow + $IDX(ROWMAX) - 1}]
		set i 0
		for {set row $start} {$row < $endRow} {incr row} {
			incr i
			if {$row == $bufRow && $mode != "forced"} {
				append drawBuffer "\n"
			} else {
				set line [linerange $row]
				append drawBuffer [clearline]
				if {
					![llength $selection_range] ||
					[lindex $selection_range 0] >= $row ||
					$row >= [lindex $selection_range 2]
				} {
					append drawBuffer [syntaxHilight $line 0]
				}
				append drawBuffer [drawSelection $row $line $selection_range]
				append drawBuffer [drawTabGuides $row $line]
				append drawBuffer "\n"
			}
		}
	}

	set line [linerange $bufRow]
	set viewCol [set col [getCol $bufRow $bufCol]]
	if {$viewCol >= $IDX(COLMAX)} {set viewCol $IDX(COLMAX)}

	if {$IDX(ROWLAST) != $startRow ||
		$mode == "line" ||
		$mode == "edit" ||
		$mode == "partial"
	} {
		set startCol [expr {$col-$viewCol}]
		if {$mode != "line" ||
			$IDX(COLLAST) != $startCol || 
			[llength $selection_range]
		} {
			append drawBuffer [doGoto $viewRow 1]
			append drawBuffer [clearline]
			append drawBuffer [syntaxHilight $line $startCol]
			append drawBuffer [drawSelection $row $line $selection_range]
			if {$startCol <= 1} {
				append drawBuffer [drawTabGuides $row]
			}
			set IDX(COLLAST) $startCol
		}
	}

	if {$IDX(ROWLAST) != $startRow} {
		set IDX(ROWLAST) $startRow
	}

	idx [expr {$bufRow + 1}] [expr {$bufCol+1}]

	append drawBuffer [doGoto $viewRow $viewCol]

	# Output line at a time to avoid causing the terminal to hang:
	set d [split $drawBuffer \n]
	foreach line [lrange $d 0 end-1] {
		puts $line
	}
	puts -nonewline [lindex $d end]
	
	flush stdout
}

proc lastModified {} {
	global filename
	if [file exists $filename] {
		return [file mtime $filename]
	}
	return 0
}

################################
# main()
################################
proc edittext {} {
	global BUFFER IDX viewRow viewCol bufRow bufCol writable tabCompleteWord
	global init_commands keybuffer mtime insertToSelection

	set IDX(ROWLAST) -1 ; # last row most recently displayed in view
	set IDX(COLLAST) -1
	set char ""				 ; # last char received
	set line [lindex $BUFFER $bufRow] ; # line data of current line
	set mtime [lastModified]

	handleRedraw
	goto home; flush stdout
	set keybuffer ""
	set printbuffer ""
	set timestamp [clock seconds]
	set prevRow $bufRow
	set ::keyEvent ""
	foreach cmd $init_commands {
		eval $cmd
	}

	while {$char != "\u0011"} {
		append keybuffer [read stdin]
		if [eof stdin] {return done}
		if {$keybuffer == ""} {
			set now [clock seconds]
			if {$now != $timestamp} {
				set ::clickCount 0
				set timestamp $now
				set changed 0
				getRowColMax
				if {$changed} {
					status
					idx $bufRow $bufCol
					handleRedraw forced
				}
			}
			if {$printbuffer != ""} {
				handleInsert
				if {[llength $::bufSelection] || $insertToSelection} {
					set insertToSelection 0
					handleRedraw forced
				} else {
					if {$prevRow != $bufRow} {
						set prevRow $bufRow
						handleRedraw
					}
					handleRedraw edit
				}
				set printbuffer ""
			}
			# Check if the file on disk has changed
			set lastModified [lastModified]
			if {$lastModified != $mtime} {
				set mtime $lastModified
				handleReload [join {
					"File on disk has changed." 
					"Discard unsaved changes and reload?"
				} " "]
			}
			fileevent stdin readable {
				set ::keyEvent ""
				append ::keybuffer [read stdin]
			}
			vwait ::keyEvent
			update
			continue
		}
		set char [readbuf]

		if {[string is print $char] || $char == "\t"} {
			append printbuffer $char
		} elseif {$char == "\n" || $char == "\r"} {
			handleInsert
			handleNewline
			if {$keybuffer == ""} {
				if {$insertToSelection} {
					set insertToSelection 0
					handleRedraw forced
				} else {
					handleRedraw
				}
			}
			set printbuffer ""
		} else {
			handleControls
			set prevRow $bufRow
		}
	}
}

proc getRowColMax {} {
	uplevel 1 {
		if {![catch {exec stty -a} err]} {
			if {![regexp {rows (\d+); columns (\d+)} $err -> rows cols]} {
				if {![regexp {(\d+) rows; (\d+) columns;} $err -> rows cols]} {
					return
				}
			}
			if {$rows != 0 && $cols != 0} {
				if {$rows != $IDX(ROWMAX)} {
					set IDX(ROWMAX) $rows
					set changed 1
				}
				if {$cols != $IDX(COLMAX)} {
					set IDX(COLMAX) $cols
					set changed 1
				}
			}
		}
		if {$changed} {
			set IDX(ROWCOL) [expr {$IDX(COLMAX) - $IDX(ROWCOLLEN)}]
		}
	}
}

proc openFile {} {
	global BUFFER filename writable

	if [file isfile $filename] {
		if [file readable $filename] {
			set mode ""
			set f [open $filename r]
			set data [read $f]
			if {[file extension $filename] == ".tsuspend"} {
				set mode [resume $data]
				set filename [file rootname $filename]
			}
			if {$mode != "suspend"} {
				set BUFFER [split $data "\n"]
			}
			close $f
			if {[file writable $filename] == 0} {
				set writable 0
			}
			set openMode ""
			if {$mode == "suspend"} {
				set openMode " RESUMED"
			}
			if {$writable} {
				status "Opened: $filename$openMode"
			} else {
				status "Opened: $filename$openMode, READ ONLY!"
			}
			loadTags [file normalize $filename]
			loadConfig [file normalize $filename]
		} else {
			puts "Can't read file: \"$filename\""
			exit
		}
		return 1
	}
	return 0
}

proc saveFile {} {
	global filename BUFFER modified mtime

	if {!$modified} return

	if [getConfirmation "Save '$filename'?"] {
		set outfile [open $filename w ]
		for {set i 0} {$i<[expr [llength $BUFFER]-1]} {incr i} {
			puts $outfile [lindex $BUFFER $i]
		}
		puts -nonewline $outfile [lindex $BUFFER end]
		close $outfile
		status " Saved '$filename' ([llength $BUFFER] lines)"

		# Delete suspended file:
		if [file exists $filename.tsuspend] {
			file delete $filename.tsuspend
		}
		
		set mtime [lastModified]
		set modified 0
	} else {
		status " Aborted"
	}
	flush stdout
}

proc bufferModified {args} {
	global modified
	set modified 1
}

array set tags {}
set tags_root [pwd]

proc loadConfig {fileName} {
	while {[set dir [file dirname $fileName]] != "/"} {
		if {[file isfile $dir/.tcled.conf] && [file readable $dir/.tcled.conf]} {
			set f [open $dir/.tcled.conf]
			set txt [read $f]
			close $f

			foreach line [split $txt \n] {
				if {[regexp {(\w+)\s+(\w+)} $line -> var val]} {
					uplevel #0 "set $var $val"
				}
			}

			return
		}
		set fileName $dir
	}
}

proc loadTags {fileName} {
	global tags tags_root

	while {[set dir [file dirname $fileName]] != "/"} {
		if {[file isfile $dir/tags] && [file readable $dir/tags]} {
			set f [open $dir/tags]
			set txt [read $f]
			close $f

			set tags_root $dir

			foreach line [split $txt \n] {
				if {![regexp {^!_TAG_} $line]} {
					lassign [split $line \t] tagName tagLocation searchSpec

					if {$tagName != "" && $searchSpec != ""} {
						if {![info exists tags($tagName)]} {
							set tags($tagName) [list $tagLocation $searchSpec]
						} else {
							lappend tags($tagName) $tagLocation $searchSpec
						}
					}
				}
			}

			return
		}
		set fileName $dir
	}
}

proc console_edit {fileName} {
	global BUFFER IDX tabstop bufRow bufCol writable
	global filename fileext comeFrom

	set IDX(ROWMAX) 24
	set IDX(COLMAX) 80
	set IDX(ROWCOLLEN) 18
	set changed 1
	set BUFFER ""

	getRowColMax

	
	if {![openFile]} {
		status "New file: $fileName"
	}

	if {$fileext == ""} {
		set topline [lindex $BUFFER 0]
		if {[string range $topline 0 1] == "#!"} {
			set fileext [lindex [split $topline "/"] end]
		} else {
			set fileext [lindex [split [file tail $filename] "."] end]
		}
	}
	initSyntaxRules $fileext

	trace variable BUFFER w bufferModified

	fconfigure stdin -buffering none -blocking 0
	fconfigure stdout -buffering full -translation crlf

	if {[catch {
		exec stty raw -echo
	
		# Set window title:
		puts -nonewline [WINDOW_TITLE "$comeFrom$filename"]
		# Enable mouse reporting:
		puts -nonewline [ESC_ ?1002h ][ESC_ ?1015h]
	}]} {
		puts stderr "Warning, not a terminal!"
	}
	
	set err [catch edittext]
	if {$err == 0} {
		saveFile
	} else {
		doExit $::errorInfo
	}
	
	doExit
}

proc doExit {{err ""}} {
	# Reset terminal:
	puts -nonewline [ESC c [ESC_ 2J]]
	# Disable mouse reporting:
	puts -nonewline [ESC_ ?1002l][ESC_ ?1015l]
	flush stdout
	catch {exec stty -raw echo}
	after 100
	
	if {$err != ""} {
		puts $err
		flush stdout
	}
	exit 0
}

proc initSyntaxRules {fileext} {
	global syntaxRules blockCommentRules hilight block_comment_symbol
	global STRINGS NUMBERS STRING_STYLE NUMBER_STYLE COMMENT_FORMAT
	global fg bg style

	# Initialize syntax hilighting rules
	set hilight ""
	foreach {filepattern rule} [string map [
		list \
			{$STRINGS} $STRINGS \
			{$NUMBERS} $NUMBERS \
			{$COMMENT_FORMAT} $COMMENT_FORMAT \
			{$STRING_STYLE} $STRING_STYLE \
			{$NUMBER_STYLE} $NUMBER_STYLE
	] $syntaxRules] {
		if [regexp $filepattern $fileext] {
			foreach {pattern attr} $rule {
				lappend hilight $pattern [subst $attr]
			}
		}
	}
	
	# Set block comment style
	foreach {filepattern rule} $blockCommentRules {
		if [regexp $filepattern $fileext] {
			set block_comment_symbol $rule
			break
		}
	}
}

# Parse command line arguments:
set cmdline $argv
set argv ""
set init_commands {}
while {[llength $cmdline]} {
	set arg [shift cmdline]
	switch -exact -- $arg {
		-s {
			set f [open [shift cmdline] r]
			append syntaxRules "\n[read $f]"
			close $f
		}
		-S {
			set f [open [shift cmdline] r]
			set syntaxRules [read $f]
			close $f
		}
		-f {set fileext [shift cmdline]}
		-r {set writable 0}
		-define {
			set var [shift cmdline]
			global $var
			set $var [shift cmdline]
		}
		-G {
			lappend init_commands "handleGotoLine [shift cmdline]"
		}
 		-F {
 			set searchpattern [shift cmdline]
			lappend init_commands "handleSearch"
		}
		--help {
			puts "tcled: editor written in tcl"
			puts "usage: tcled ?options? filename\n"
			puts "Where options are:"
			puts "  -s file    append syntax rules from file"
			puts "  -S file    replace syntax rules with rules from file"
			puts "  -f ext     pretend file extension is ext"
			puts "  -r         open file as read-only"
			puts "  -G line    go to line number"
			puts "  +line      shortcut for -G line"
			puts "  -F regex   find"
			exit
		}
		default {
			if [regexp {^\+(\d+)$} $arg - line] {
				lappend init_commands "handleGotoLine $line"
			} else {
				lappend argv $arg
			}
		}
	}
}

set syntaxRules [stripComments $syntaxRules]

if {[llength $argv] == 0} {
	puts "Please specify a filename:"
	gets stdin filename
	if {$filename != ""} {
		console_edit $filename
	}
} else {
	foreach filename $argv {
		console_edit $filename
	}
}
